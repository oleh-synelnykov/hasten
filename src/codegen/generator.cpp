#include "codegen/generator.hpp"

#include "emitter.hpp"
#include "file_writer.hpp"
#include "ir_builder.hpp"

#include <filesystem>
#include <sstream>

namespace hasten::codegen
{
namespace
{

/**
 * @brief Represents the targets generated for a module.
 */
struct ModuleTargets {
    std::string module_name;                              ///< Name of the module
    std::string base_name;                                ///< Base name for generated targets
    std::filesystem::path include_dir;                    ///< Include directory for generated headers
    std::filesystem::path header;                         ///< Main header file
    std::vector<Emitter::InterfaceArtifacts> interfaces;  ///< Generated interface artifacts
};

std::expected<std::string, std::string> build_cmake_manifest(const std::vector<ModuleTargets>& modules)
{
    std::ostringstream out;
    out << "# Auto-generated by Hasten. Include this file to register generated targets.\n\n";
    out << "find_package(hasten_runtime REQUIRED)\n\n";

    auto cmake_escape_path = [](const std::filesystem::path& path) {
        return path.generic_string();
    };

    for (const auto& module : modules) {
        if (module.interfaces.empty()) {
            continue;
        }

        const auto common_target = "hasten_" + module.base_name + "_common";
        out << "\n# Module " << module.module_name << "\n";
        out << "if(NOT TARGET " << common_target << ")\n";
        out << "  add_library(" << common_target << " INTERFACE)\n";
        out << "  target_include_directories(" << common_target << " INTERFACE \""
            << cmake_escape_path(module.include_dir) << "\")\n";
        out << "endif()\n";

        for (const auto& iface : module.interfaces) {
            const auto client_target = "hasten_" + module.base_name + "_" + iface.interface_name + "_client";
            const auto server_target = "hasten_" + module.base_name + "_" + iface.interface_name + "_server";

            out << "if(NOT TARGET " << client_target << ")\n";
            out << "  add_library(" << client_target << " OBJECT\n";
            out << "      \"" << cmake_escape_path(iface.client_source) << "\")\n";
            out << "  target_link_libraries(" << client_target << " PUBLIC " << common_target
                << " hasten_runtime::hasten_runtime)\n";
            out << "endif()\n\n";

            out << "if(NOT TARGET " << server_target << ")\n";
            out << "  add_library(" << server_target << " OBJECT\n";
            out << "      \"" << cmake_escape_path(iface.server_source) << "\")\n";
            out << "  target_link_libraries(" << server_target << " PUBLIC " << common_target
                << " hasten_runtime::hasten_runtime)\n";
            out << "endif()\n\n";
        }
    }

    return out.str();
}

}  // namespace

Generator::Generator(const frontend::Program& program, GenerationOptions options)
    : _program(program)
    , _options(std::move(options))
{
}

std::expected<void, std::string> Generator::run()
{
    namespace fs = std::filesystem;

    fs::path root = _options.output_dir;
    if (root.empty()) {
        root = fs::current_path();
    }

    std::error_code ec;
    fs::create_directories(root, ec);
    if (ec) {
        return std::unexpected("Failed to create output directory: " + ec.message());
    }

    Emitter emitter(_options, root);

    auto unit = ir::build_internal_representation(_program);

    std::vector<ModuleTargets> manifest_modules;
    for (const auto& module : unit.modules) {
        auto emitted = emitter.emit_module(module);
        if (!emitted) {
            return std::unexpected(emitted.error());
        }
        ModuleTargets mt;
        mt.module_name = module.name;
        mt.base_name = emitted->module_base;
        mt.include_dir = fs::absolute(emitted->include_dir);
        mt.header = fs::absolute(emitted->header);
        for (const auto& iface : emitted->interfaces) {
            Emitter::InterfaceArtifacts abs_iface = iface;
            abs_iface.client_source = fs::absolute(iface.client_source);
            abs_iface.server_source = fs::absolute(iface.server_source);
            mt.interfaces.push_back(std::move(abs_iface));
        }
        manifest_modules.push_back(std::move(mt));
    }

    const auto manifest_path = root / "generated.cmake";
    return write_file_if_changed(manifest_path, build_cmake_manifest(manifest_modules));
}

}  // namespace hasten::codegen
